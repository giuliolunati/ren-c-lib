#!/usr/bin/r3

REBOL[]


; GENERAL PURPOSE

fail: func [msg] [
  if block? msg [msg: spaced msg]
  print ["Failed:" msg]
  quit 1
]

prompt: func [msg] [
  write-stdout msg
  input
]


; SPECIFIC

profile: func [time] [
  ; 9:30-12:30, 14:30-19:30, 22:00-24:00
  (case [
    time < 9:30 [0:0]
    time < 12:30 [time - 9:30]
    time < 14:30 [3:00]
    time < 19:30 [time - 11:30]
    time < 22:00 [8:00] 
    true [time - 14:00]
  ]) / 10:00
]

diff-date: func [d1 d2] [
  d1/date - d2/date + (profile d1/time) - (profile d2/time)
]

load-task-line: func [
  l "text line"
  <local> desc period date score tasks amount
][
  ; score amount period date description
  if empty? trim l [return _]
  score: transcode/next l 'l
  amount: transcode/next l 'l
  period: transcode/next l 'l
  (date? date: transcode/next l 'l) or
    (return null)
  date/zone: null
  date/time: default [0:0]
  l: trim l
  if score [
    score: amount * (diff-date t0 date) / period + score 
  ]
  make map! :[
    'score score
    'amount amount
    'period period
    'date t0
    'desc l
  ]
]

load-stat-line: func [l] [
  load l
]

load-task-file: func [
  file [file!]
  return: [block!]
  stats: [map!]
] [
  tasks: make block! 8
  days: make block! 8
  let l: read/lines file
  let x

  for-each l l [
    case [
      x: load-task-line l [append tasks x]
      x: load-stat-line l [append days x]
    ]
  ]
  sort/skip days 2
  if stats [set stats make map! days]
  return tasks
]

days: make map! [
  lun 1
  mar 2
  mer 3
  gio 4
  ven 5
  sab 6
  dom 7
]

smart-date: func [d] [
  if date? d [return d]
  let i
  case [
    all [word? d, i: days/:d] [
      (i - t0/weekday) mod 7 + t0
    ]
  ]
]

set-due-date: func [t d] [
  d: smart-date d
  d/time: 23:59
  t/score: (diff-date t0 d) / t/period + 1 * t/amount
]

set-start-date: func [t d] [
  d: smart-date d
  d/time: 0:0
  t/score: (diff-date t0 d) / t/period * t/amount
]

form-task: func [t] [
  let score: t/score
  if score [score: to-integer score]
  format [-4 " " -3 "/" 3 " "]
    :[score t/amount t/period t/desc]
]

write-tasks: func [file tasks stats] [
  let text: make text! 8
  for-each t tasks [
    append text spaced [
      either t/score
      [ round/to t/score 0.01 ]
      [ "_" ]
      t/amount
      t/period
      t/date
      t/desc newline
    ]
  ]
  append text newline
  for-each k stats [
    append text spaced [k stats/:k]
    append text newline
  ]
  write file text
]

; MAIN

t0: now, t0/zone: null

file: to-file any [
  pick system/script/args 1
  %tasks.txt
]

[tasks stats]: load-task-file file

forever [
  sort/compare tasks
    [a b] -> [case [
      not a/score [false]
      not b/score [true]
      true [a/score > b/score]
    ]]
  n: length-of tasks
  count-down n length-of tasks [
    
    print [format -2 n form-task tasks/:n]
  ]
  forever [
    trap [cmd: load prompt "task>"] else [break]
    print "??"
  ]
  parse  cmd [
    end (break)
    | 'x (write-tasks file tasks stats, quit 0)
    | '+ (
        desc: trim prompt "desc? "
        period: transcode/next prompt "period? " #
        amount: transcode/next prompt "amount? " #
        if time? period [period: me / 24:00]
        append tasks make map! :[
          'score 0
          'period period
          'amount amount
          'date t0
          'desc desc
        ]
      )
    | set n integer!
      (t: tasks/:n)
      [ 'x (remove at tasks n)
      | '- (t/score: _)
      | set d [integer!]
        ( if d = 0 [t/score: 0]
          else [
            t/score: me - d
            t: any [stats/(t0/date) 0]
            stats/(t0/date): t + d
          ]
        )
      | '< set d skip (set-due-date t d)
      | '> set d skip (set-start-date t d)
      ]
    | (print "??")
  ] 
]
; vim: set syn=rebol et sw=2:
